! NMDC
! A code for molecular dynamics using a Nose-Poincare thermostat and 
! an Andersen barostat.
!
! N Park
! AWE Aldermaston, Reading, Berks
!
! RCS data
! $Id: calc.f90,v 1.16 2005/05/06 10:53:31 gnpk Exp gnpk $

MODULE calc_mod

  USE kind_mod

  IMPLICIT NONE

  PUBLIC potential_and_forces, pressure, PKE, get_H_NPA, neighbour
  PRIVATE

  REAL(KIND=DBL), ALLOCATABLE, DIMENSION(:,:), SAVE :: elist
  REAL(KIND=DBL), SAVE :: sigma                       ! Used for pressure calculation (force)
  REAL(KIND=DBL), PARAMETER :: epsilon = 1.0d-200     ! for zero comparison

  INTEGER, ALLOCATABLE, DIMENSION(:,:), SAVE :: nlist
  INTEGER, PARAMETER :: maxneigh = 4000

CONTAINS

  SUBROUTINE potential_and_forces(n,meth,r,bounds,force,E_tot,crv)

    USE Lennard_Jones
    USE EAM
    USE MEAM
    USE soft_sphere
    USE powerlaw
    USE setup, ONLY : LJ_rcut, eam_dat, meam_dat

    IMPLICIT NONE
    INTEGER, INTENT(in) :: n                               ! N atoms
    INTEGER, INTENT(in) :: meth                            ! method
    REAL(KIND=DBL), DIMENSION(:,:), INTENT(in) :: r        ! positions
    REAL(KIND=DBL), DIMENSION(:,:), INTENT(in) :: bounds   ! box lims (side, dir)

    REAL(KIND=DBL), DIMENSION(3,n), INTENT(out) :: force   ! Directional force vectors
    REAL(KIND=DBL), INTENT(out) :: E_tot
    REAL(KIND=DBL), INTENT(in) :: crv                      ! cube root volume (side length)

    ! local variables
    REAL(KIND=DBL), ALLOCATABLE, DIMENSION(:,:) :: eam_df_store, eam_dphi_store
    REAL(KIND=DBL), ALLOCATABLE, DIMENSION(:) :: eam_rho, eam_phi_sum
    REAL(KIND=DBL), DIMENSION(n) :: E_at
    REAL(KIND=DBL) :: rc2                                  ! x,y,z,r, rCutoff squared
    REAL(KIND=DBL) :: eam_f, eam_df, eam_phi, eam_dphi
    REAL(KIND=DBL) :: dsdr, dridr                          ! d_psi/d_r
    INTEGER :: i, j, k, nni, nnj, nnk, dir

    LOGICAL, SAVE :: start=.TRUE.

    ! MEAM temp
    REAL(kind=dbl) :: rho_0, rho_1, rho_2, rho_3, rhobar
    REAL(kind=dbl) :: rho_a0, rho_a1, rho_a2, rho_a3
    REAL(kind=dbl) :: scr, Sij, fc, dfc, dRho, gamma
    REAL(kind=dbl) :: rij, rij2, rik, rkj, rx, ry, rz, rx2, ry2, rz2, rx3, ry3, rz3
    REAL(kind=dbl) :: drikdra, drkjdra, dsik, dxik, dskj, dxkj
    REAL(kind=dbl) :: c1, c2, c3, c4, c5, c6, c7, c8, c9, c10
    REAL(kind=dbl), DIMENSION(3) :: drijdra, dSij
    REAL(KIND=DBL), DIMENSION(3) :: length
    REAL(kind=dbl), ALLOCATABLE, DIMENSION(:) :: term, phi
    REAL(kind=dbl), ALLOCATABLE, DIMENSION(:,:) :: dphi, drhobar
    REAL(kind=dbl), ALLOCATABLE, DIMENSION(:,:) :: drho_0, drho_1, drho_2, drho_3
    REAL(kind=dbl), SAVE :: rb0re

    REAL(KIND=DBL) :: xdiff, ydiff, zdiff, r_ij            ! x,y,z,r, rCutoff squared


    !Reset forces, presHold and energy to zero
    force = 0.0d0
    sigma = 0.0d0

    E_at = 0.0d0
    E_tot = 0.0d0



    SELECT CASE (meth)
    CASE (1)       ! ideal gas; U=0

    ! =================================================

    CASE (2) ! Lennard-Jones

       !Set r2 cut-off distance
       rc2 = LJ_rcut*LJ_rcut

       DO dir=1,3
         length(dir) = bounds(2,dir)-bounds(1,dir)
       END DO


       DO i=1, n ! over atoms
          DO nni= 1,nlist(0,i)  ! over neighbours
             j=nlist(nni,i)

             CALL getDistances(r, length, i, j, r_ij, xdiff, ydiff, zdiff)

             IF (r_ij.LE.rc2) THEN
               r_ij = DSQRT(r_ij)

               dsdr = ljgu(r_ij)

               E_at(i) = E_at(i) + 0.5d0*ljpf(r_ij)
               sigma = sigma - dsdr*r_ij

               force(1,i) = force(1,i) - dsdr*xdiff/r_ij
               force(2,i) = force(2,i) - dsdr*ydiff/r_ij
               force(3,i) = force(3,i) - dsdr*zdiff/r_ij
             END IF

          END DO

       END DO

    ! =================================================
       
    CASE (3) ! soft sphere
       DO i=1, n ! over atoms
          DO nni= 1,nlist(0,i)  ! over neighbours
             j=nlist(nni,i)

             CALL getDistances(r, length, i, j, r_ij, xdiff, ydiff, zdiff)

             dsdr = ssgu(r_ij)
             E_at(i) = E_at(i) + 0.5d0*sspf(r_ij)

             force(1,i) = force(1,i) + dsdr*xdiff/r_ij
             force(1,i) = force(1,i) + dsdr*ydiff/r_ij
             force(1,i) = force(1,i) + dsdr*zdiff/r_ij
          END DO
       END DO


    ! =================================================

    CASE (4) ! power law
       DO i=1, n ! over atoms
          DO nni= 1,nlist(0,i)  ! over neighbours
             j=nlist(nni,i)

             CALL getDistances(r, length, i, j, r_ij, xdiff, ydiff, zdiff)

             IF (r_ij.LE.eam_dat%rc2) THEN
                dsdr = pwrgu(r_ij)
                E_at(i) = E_at(i) + 0.5d0*pwrpf(r_ij)
             ELSE
                dsdr = 0.
                E_at(i) = E_at(i) + 0.0d0
             END IF

             force(1,i) = force(1,i) + dsdr*xdiff/r_ij
             force(1,i) = force(1,i) + dsdr*ydiff/r_ij
             force(1,i) = force(1,i) + dsdr*zdiff/r_ij
          END DO
       END DO

    ! =================================================

    CASE (5) ! embedded atom method

             IF(start) THEN
                ALLOCATE(eam_df_store(maxneigh,n), eam_dphi_store(maxneigh,n), &
                     eam_rho(n), eam_phi_sum(n))
                start = .FALSE.
             END IF
             eam_rho     = 0.0d0
             eam_df_store  = 0.0d0
             eam_dphi_store = 0.0d0
             eam_phi_sum = 0.0d0

             DO i=1, n ! over atoms
                DO nni= 1,nlist(0,i)  ! over neighbours
                   j=nlist(nni,i)

                   CALL getDistances(r, length, i, j, r_ij, xdiff, ydiff, zdiff)

                   IF (r_ij.LE.eam_dat%rc2) THEN
                      dsdr = eamgu(r_ij,eam_f,eam_phi,eam_df,eam_dphi)
                      eam_rho(i) = eam_rho(i) + eam_f
                      eam_df_store(nni,i)  = eam_df
                      eam_dphi_store(nni,i) = eam_dphi

                      eam_phi_sum(i) = eam_phi_sum(i) + eam_phi
                   END IF
                END DO
             END DO

             DO i=1,n ! over atoms again
                DO nni = 1, nlist(0,i)! over neighbours again
                   j = nlist(nni,i)

                   CALL getDistances(r, length, i, j, r_ij, xdiff, ydiff, zdiff)

                   IF (r_ij.LE.eam_dat%rc2) THEN
                      dsdr = eam_dat%D * (2.0d0 + LOG(eam_rho(i)*eam_rho(j))) 

                      dridr = xdiff/r_ij
                      force(1,i) = force(1,i) + dsdr * eam_df_store(nni,i)*dridr &
                                            + eam_dphi_store(nni,i)*dridr

                      dridr = ydiff/r_ij
                      force(2,i) = force(2,i) + dsdr * eam_df_store(nni,i)*dridr &
                                            + eam_dphi_store(nni,i)*dridr

                      dridr = zdiff/r_ij
                      force(3,i) = force(3,i) + dsdr * eam_df_store(nni,i)*dridr &
                                            + eam_dphi_store(nni,i)*dridr

                   END IF
                END DO
                eam_f = eam_dat%D * eam_rho(i) * LOG(eam_rho(i))
                E_at(i) = eam_f + 0.5d0*eam_phi_sum(i)

             END DO

    ! =================================================

    CASE DEFAULT
      CONTINUE       ! do nothing; same as ideal gas

    END SELECT


    E_tot = SUM(E_at)


    RETURN

  END SUBROUTINE potential_and_forces

  !=============================================================================

  REAL(KIND=DBL) FUNCTION pressure(v,pKE)

    IMPLICIT NONE

    REAL(KIND=DBL), INTENT(in) :: v                       ! volume
    REAL(KIND=DBL), INTENT(in) :: pKE                     ! Physical kinetic energy ( 0.5 mv2 )


    pressure = 2.0d0*pKE + 0.5d0*sigma 
    pressure = pressure/(3.0d0*v)

    RETURN

  END FUNCTION pressure

  !=============================================================================

  REAL(KIND=DBL) FUNCTION PKE(n,p,m,crv,s)
    ! PKE is the Physical Kinetic Energy of the atoms (not scaled)

    !        1                  p^2
    !   = ------------  . sum{------}
    !      s^2.v^(2/3)          m

    IMPLICIT NONE

    INTEGER, INTENT(in)        :: n
    REAL(KIND=DBL), DIMENSION(:,:), INTENT(in) :: p   !momenta
    REAL(KIND=DBL), DIMENSION(:),   INTENT(in) :: m   !mass
    REAL(KIND=DBL), INTENT(in) :: crv                 !cube root of volume (side length)
    REAL(KIND=DBL), INTENT(in) :: s

    INTEGER :: i!, dir
    REAL(KIND=DBL) :: p2
    REAL(KIND=DBL) :: mv2Sum

    mv2Sum = 0.0d0
    DO i=1,n
       !These are scaled momenta
       p2   = p(1,i)*p(1,i) + p(2,i)*p(2,i) + p(3,i)*p(3,i)
       mv2Sum = mv2Sum + p2/m(1)
    END DO

    !Convert to physical units by un-scaling ( scaled v = v * crv * s  )
    PKE = 0.5d0 * mv2Sum / (crv*crv * s*s)

    RETURN

  END FUNCTION PKE

  !=============================================================================

  SUBROUTINE neighbour(n,r,bounds,m)

    USE setup, ONLY : LJ_rcut, eam_dat

    IMPLICIT NONE

    INTEGER, INTENT(in) :: n                                ! N atoms
    REAL(KIND=DBL), DIMENSION(:,:), INTENT(inout) :: r      ! Atom coordinates
    REAL(KIND=DBL), DIMENSION(:,:), INTENT(in) :: bounds    ! Boundaries
    INTEGER, INTENT(in) :: m                                ! Potential method

    REAL(KIND=DBL) :: rc2                                   ! Cut-off distance squared
    REAL(KIND=DBL), DIMENSION(3) :: diff, length
    REAL(KIND=DBL) :: r_ij
    INTEGER :: i, j, dir, nni, nnj
    INTEGER :: bign
    INTEGER, SAVE :: bign_last = 0


    IF (.NOT.ALLOCATED(nlist)) THEN
       ALLOCATE(nlist(0:maxneigh,n))
       ALLOCATE(elist(0:maxneigh,n))
    END IF


    !Calculate box dimensions
    DO dir=1,3
       length(dir) = bounds(2,dir)-bounds(1,dir)
    END DO


    !Implement pbc
    DO i=1,n
       DO dir = 1,3
          IF (r(dir,i).lt.bounds(1,dir)) r(dir,i) = r(dir,i) + length(dir)
          IF (r(dir,i).ge.bounds(2,dir)) r(dir,i) = r(dir,i) - length(dir)
       END DO
    END DO


    SELECT CASE (m)
      CASE(2)
        rc2 = 1.2d0*LJ_rcut
      CASE(5)
        rc2 = 1.5d0*eam_dat%rc2
      CASE default
        rc2 = 2.0d0*eam_dat%rc2
    END SELECT
    rc2 = rc2*rc2                                          


    nlist = 0
    bign = 0

    DO i=1,n-1
       DO j= i+1,n

          r_ij = 0.0d0
          DO dir = 1,3
             diff(dir) = r(dir,j)-r(dir,i)

             ! Apply minimum image convention
             IF (diff(dir) .GT. 0.5*length(dir)) THEN
                diff(dir) = diff(dir) - length(dir)
             ELSE IF (diff(dir) .LT. -0.5*length(dir)) THEN
                diff(dir) = diff(dir) + length(dir)
             END IF

             r_ij = r_ij + diff(dir)*diff(dir)
          END DO

          IF (r_ij.LE.rc2) THEN       
             nni = nlist(0,i) + 1
             IF (nni.GT.bign) bign = nni
             IF (nni.GT.maxneigh) CALL error('Boost maxneigh')
             nlist(nni,i)=j
             nlist(0,i) = nni

             nnj = nlist(0,j) + 1
             IF (nnj.GT.bign) bign = nnj
             IF (nnj.GT.maxneigh) CALL error('Boost maxneigh')
             nlist(nnj,j)=i
             nlist(0,j) = nnj
          END IF
       END DO
    END DO

    IF (bign.GT.bign_last) THEN
       bign_last = bign
    END IF

    RETURN

  END SUBROUTINE neighbour

  !=============================================================================

  SUBROUTINE getDistances(pos, length, atomA, atomB, r2, xdiff, ydiff, zdiff)

    IMPLICIT NONE

    REAL(KIND=DBL), DIMENSION(:,:), INTENT(in) :: pos        ! positions
    REAL(KIND=DBL), DIMENSION(:), INTENT(in) :: length       ! box lengths
    INTEGER, INTENT(in) :: atomA, atomB                      ! atom identities

    ! local variables
    REAL(KIND=DBL), INTENT(out) :: xdiff, ydiff, zdiff, r2   ! x,y,z,r2


    r2 = 0.0d0
    xdiff = pos(1,atomA)-pos(1,atomB)
    IF (xdiff .GT. 0.5*length(1)) THEN
      xdiff = xdiff - length(1)
    ELSE IF (xdiff .LT. -0.5*length(1)) THEN
      xdiff = xdiff + length(1)
    END IF
    r2 = r2 + xdiff*xdiff

    ydiff = pos(2,atomA)-pos(2,atomB)
    IF (ydiff .GT. 0.5*length(2)) THEN
      ydiff = ydiff - length(2)
    ELSE IF (ydiff .LT. -0.5*length(2)) THEN
      ydiff = ydiff + length(2)
    END IF
    r2 = r2 + ydiff*ydiff

    zdiff = pos(3,atomA)-pos(3,atomB)
    IF (zdiff .GT. 0.5*length(3)) THEN
      zdiff = zdiff - length(3)
    ELSE IF (zdiff .LT. -0.5*length(3)) THEN
      zdiff = zdiff + length(3)
    END IF
    r2 = r2 + zdiff*zdiff


  END SUBROUTINE getDistances

  !=============================================================================

  REAL(KIND=DBL) FUNCTION get_H_NPA(s,v,gkT,p,pKE,spot,pi_v,q_v,pi_s,q_s)

    IMPLICIT NONE

    REAL(KIND=DBL), INTENT(in) :: s     ! s_n
    REAL(KIND=DBL), INTENT(in) :: v     ! volume
    REAL(KIND=DBL), INTENT(in) :: gkT   ! degfKT
    REAL(KIND=DBL), INTENT(in) :: p     ! ext_press
    REAL(KIND=DBL), INTENT(in) :: pKE   ! KE of atoms
    REAL(KIND=DBL), INTENT(in) :: spot  ! stored pot energy
    REAL(KIND=DBL), INTENT(in) :: pi_v  ! KE of Pressure piston
    REAL(KIND=DBL), INTENT(in) :: q_v   ! Mass of Pressure piston
    REAL(KIND=DBL), INTENT(in) :: pi_s  ! KE of Temperature piston
    REAL(KIND=DBL), INTENT(in) :: q_s   ! Mass of Temperature piston


    get_H_NPA = pKE + spot + ((0.5*pi_v*pi_v)/q_v) + ((0.5*pi_s*pi_s)/q_s) &
                + (gkT*DLOG(s)) + (p*v) 

    RETURN

  END FUNCTION get_H_NPA

  !=============================================================================
  !=============================================================================

END MODULE calc_mod


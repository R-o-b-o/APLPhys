! NMDC
! A code for molecular dynamics using a Nose-Poincare thermostat and 
! an Andersen barostat.
!
! N Park
! AWE Aldermaston, Reading, Berks
! RCS data
! $Id: input.f90,v 1.6 2005/05/05 14:51:55 gnpk Exp $


MODULE user_vars

  USE kind_mod
  USE global_params_mod
  IMPLICIT NONE

  PRIVATE

  PUBLIC get_user_vars

CONTAINS

  !=============================================================================

  SUBROUTINE get_user_vars(bounds, Press, Temp, V_mass, S_mass, n_atoms, &
       pot_meth, n_steps, timestep, neigh_reb_freq, &
       thermo_f, snap_f, res_f, res_n, atm_file,complete)

    IMPLICIT NONE

    REAL(KIND=DBL), DIMENSION(2,3), INTENT(out) :: bounds
    REAL(KIND=DBL), INTENT(out) :: Press
    REAL(KIND=DBL), INTENT(out) :: Temp
    REAL(KIND=DBL), INTENT(out) :: V_mass
    REAL(KIND=DBL), INTENT(out) :: S_mass
    REAL(KIND=DBL), INTENT(out) :: timestep
    INTEGER, INTENT(out) :: pot_meth
    INTEGER, INTENT(out) :: n_steps
    INTEGER, INTENT(out) :: n_atoms
    INTEGER, INTENT(out) :: neigh_reb_freq
    INTEGER, INTENT(out) :: thermo_f
    INTEGER, INTENT(out) :: snap_f
    INTEGER, INTENT(out) :: res_f
    INTEGER, INTENT(out) :: res_n
    INTEGER, INTENT(out) :: atm_file
    LOGICAL, INTENT(out) :: complete


    CHARACTER(LEN=200) :: line, instruction, rest
    CHARACTER(LEN=200) :: file
    INTEGER :: loc, ierr
    REAL(KIND=DBL) :: Ve

900 FORMAT (a)
    atm_file=0

    DO
       READ (ifile,900,IOSTAT=ierr) line
       IF (ierr.EQ.-1) EXIT
       loc = 1
       instruction = strread(line, loc)

       SELECT CASE (instruction)

       CASE ('barostat')
          Press = realread(line, loc)
          Ve = realread(line, loc)
          IF (Ve.GT.1.0d-20) THEN
             V_mass = Ve
          ELSE
             V_mass = HUGE(V_mass)
          END IF

       CASE ('thermostat')
          Temp = realread(line, loc)
          Ve = realread(line, loc)
          IF (Ve.GT.1.0d-20) THEN
             S_mass = Ve
          ELSE
             S_mass = HUGE(S_mass)
          END IF

       CASE ('box')
          bounds(1,1) = realread(line, loc)
          bounds(2,1) = realread(line, loc)
          bounds(1,2) = realread(line, loc)
          bounds(2,2) = realread(line, loc)
          bounds(1,3) = realread(line, loc)
          bounds(2,3) = realread(line, loc)

       CASE ('atoms')
          rest = strread(line, loc)
          SELECT CASE (rest)
          CASE('create')
             n_atoms = intread(line, loc)
          CASE('read')
             rest = strread(line, loc)
!!$             WRITE(file,*) rest
             file = rest
             atm_file=20
             OPEN(unit=atm_file, file=file, status='old', iostat=ierr)
             IF (ierr.NE.0) CALL error('Problem with atom file')

             READ (atm_file,*)
             READ (atm_file,*)
             READ (atm_file,*)
             READ (atm_file,*) n_atoms
          CASE('restart')
             atm_file = 21
             res_n = intread(line, loc)
             n_atoms = intread(line, loc)
          END SELECT


       CASE ('timestep')
          n_steps = intread(line, loc)
          timestep = realread(line, loc)
          neigh_reb_freq = intread(line, loc)

       CASE ('output')
          thermo_f = intread(line, loc)
          snap_f = intread(line, loc)

       CASE ('restart')
          res_f = intread(line, loc)

       CASE ('potential')
          rest = strread(line, loc)

          SELECT CASE (rest)
          CASE('Lennard-Jones')
             pot_meth = 2 
             LJ_rcut = realread(line, loc)
             LJ_sigma = realread(line, loc)
             LJ_eps = realread(line, loc)
          CASE('soft-sphere')
             pot_meth = 3
          CASE('powerlaw')
             pot_meth = 4
          CASE('eam')
             pot_meth = 5
          CASE DEFAULT
             pot_meth = 1
          END SELECT

       CASE('run')
          complete = .FALSE.
          EXIT

       CASE ('#')
          WRITE(efile,*) line

       CASE ('end')
          complete = .TRUE.
          Ve = n_atoms*k_boltz*Temp/Press
          WRITE(efile,*) '# Guesstimate box side :', Ve**(1.0d0/3.0d0)
          EXIT
          !                CALL error('Job Finished')

       CASE DEFAULT

       END SELECT

    END DO


  END SUBROUTINE get_user_vars

  ! -----------------------------------------------------------------------
  ! string and number routines

  ! -----------------------------------------------------------------------
  ! returns TRUE if str1 matches 1st chars of str2, FALSE otherwise
  ! also returns m = loc of next char in str2
  ! could test if next char is a space or tab

  LOGICAL FUNCTION match(str1,str2,m)


    CHARACTER(len=*), INTENT(in) :: str1,str2
    INTEGER, INTENT(inout) :: m

    match = .FALSE.
    m = LEN(str1) + 1
    IF (LEN(str1).GT.LEN(str2)) RETURN
    IF (str1.EQ.str2(1:LEN(str1))) match = .TRUE.

    RETURN
  END FUNCTION match


  ! -----------------------------------------------------------------------
  ! return the integer that starts at loc m in str
  ! skip initial spaces and tabs
  ! scans to end of number marked by space or tab
  ! also return m = loc of char after end of number in str

  INTEGER FUNCTION intread(str,m)


    CHARACTER(len=*), INTENT(in) :: str
    INTEGER, INTENT(inout) ::  m

    INTEGER n1,n2,nmax

    n1 = m
    nmax = LEN(str)
    DO WHILE (n1.LE.nmax.AND. &
         (str(n1:n1).EQ.' '.OR.ICHAR(str(n1:n1)).EQ.9))
       n1 = n1 + 1
    ENDDO
    n2 = n1
    DO WHILE (n2.LE.nmax.AND.str(n2:n2).NE.' ' &
         .AND.ICHAR(str(n2:n2)).NE.9)
       n2 = n2 + 1
    ENDDO
    READ (str(n1:n2-1),*) intread
    m = n2

    RETURN
  END FUNCTION intread


  ! -----------------------------------------------------------------------
  ! return the real*8 that starts at loc m in str
  ! skip initial spaces and tabs
  ! scans to end of number marked by space or tab
  ! also return m = loc of char after end of number in str

  REAL(KIND=DBL) FUNCTION realread(str,m)


    CHARACTER(len=*), INTENT(in) :: str
    INTEGER, INTENT(inout) ::  m

    INTEGER n1,n2,nmax

    n1 = m
    nmax = LEN(str)
    DO WHILE (n1.LE.nmax.AND. &
         (str(n1:n1).EQ.' '.OR.ICHAR(str(n1:n1)).EQ.9))
       n1 = n1 + 1
    ENDDO
    n2 = n1
    DO WHILE (n2.LE.nmax.AND.str(n2:n2).NE.' ' &
         .AND.ICHAR(str(n2:n2)).NE.9)
       n2 = n2 + 1
    ENDDO
    READ (str(n1:n2-1),*) realread
    m = n2

    RETURN
  END FUNCTION realread


  ! -----------------------------------------------------------------------
  ! return the substring that starts at loc m in str
  ! skip initial spaces and tabs
  ! substring is any chars up to next space or tab
  ! also return m = loc of char after end of substr in str

  CHARACTER(LEN=200) FUNCTION strread(str,m)


    CHARACTER(len=*), INTENT(in) :: str
    !      CHARACTER(len=*), INTENT(out) :: substr
    INTEGER, INTENT(inout) ::  m

    INTEGER n1,n2,nmax

    n1 = m
    nmax = LEN(str)
    DO WHILE (n1.LE.nmax.AND. &
         (str(n1:n1).EQ.' '.OR.ICHAR(str(n1:n1)).EQ.9))
       n1 = n1 + 1
    ENDDO
    n2 = n1
    DO WHILE (n2.LE.nmax.AND.str(n2:n2).NE.' ' &
         .AND.ICHAR(str(n2:n2)).NE.9)
       n2 = n2 + 1
    ENDDO
    strread = str(n1:n2-1)
    m = n2

    RETURN
  END FUNCTION strread


  !! -----------------------------------------------------------------------
  !! returns the actual length of str
  !! backtracks from end of string skipping over spaces

  INTEGER FUNCTION length(str)


    CHARACTER(len=*), INTENT(in) :: str

    INTEGER n

    n = LEN(str)
    DO WHILE (n.GT.0.AND.str(n:n).EQ.' ')
       n = n - 1
    ENDDO
    length = n

    RETURN
  END FUNCTION length


  ! -----------------------------------------------------------------------
  ! write a positive integer into the beginning of a string variable
  ! return inum = length of string

  SUBROUTINE writeint(ivalue,str,inum)


    INTEGER, INTENT(in) ::  ivalue
    CHARACTER(len=*), INTENT(out) :: str
    INTEGER, INTENT(out) ::  inum

    IF (ivalue.LT.10) THEN
       WRITE (str,'(i1)') ivalue
       inum = 1
    ELSE IF (ivalue.LT.100) THEN
       WRITE (str,'(i2)') ivalue
       inum = 2
    ELSE IF (ivalue.LT.1000) THEN
       WRITE (str,'(i3)') ivalue
       inum = 3
    ELSE IF (ivalue.LT.10000) THEN
       WRITE (str,'(i4)') ivalue
       inum = 4
    ELSE IF (ivalue.LT.100000) THEN
       WRITE (str,'(i5)') ivalue
       inum = 5
    ELSE IF (ivalue.LT.1000000) THEN
       WRITE (str,'(i6)') ivalue
       inum = 6
    ELSE IF (ivalue.LT.10000000) THEN
       WRITE (str,'(i7)') ivalue
       inum = 7
    ELSE IF (ivalue.LT.100000000) THEN
       WRITE (str,'(i8)') ivalue
       inum = 8
    ELSE IF (ivalue.LT.1000000000) THEN
       WRITE (str,'(i9)') ivalue
       inum = 9
    ELSE
       WRITE (str,'(i10)') ivalue
       inum = 10
    ENDIF

    RETURN
  END SUBROUTINE writeint


END MODULE user_vars
